# RE_Proc  

目录    
1 正则表达式到NFA-epsilon的转换………………………………………………………………………2  
1.1正则表达式（RE）的处理……………………………………………………………………………………2  
1.1.1处理流程………………………………………………………………………………………………2  
1.1.2中缀表达式到后缀表达式的转换方式..………………………………………………………2  
1.1.3主要函数与数据结构定义….………………………………………………………………3  
1.2 解析后的正则表达式到NFAepsilon的转换….………………………………………………………4  
1.2.1 Thompson构造法..……………………………………………………………………………4  
1.2.2处理流程…………………………………………………………………………………………6  
1.2.3主要函数与数据结构定义..……...…………………………………………………………7  
2 NFA-epsilon到DFA的转换……………………………………………………………………..……7  
3.1  Subset construction算法介绍………………………………………………………………………………7  
3.2 算法实现………………………………………………………………………………………8  
3.3 程序流程图………………………………………………………………………………………8  
3.4 结构展示………………………………………………………………………………………9  
3 DFA到极小化DFA的转换………………………………………………………………………………10  
3.1 极小化DFA与Hopcroft算法………..………………………………………………10  
3.2 处理流程………………………………………………………………………………………11  
3.3主要函数与数据结构定义………………………………………………………………………12  
4实验结果展示………………………………………………………………………………………13  
5总结与体会………………………………………………………………………………………16  
  
1 正则表达式到NFA-epsilon的转换  
1.1正则表达式（RE）的处理  
1.1.1处理流程  
   
1.1.2中缀表达式到后缀表达式的转换方式  
从中缀式的左端开始逐个读取字符x，逐序进行如下步骤：  
①若x是操作数，则分析出完整的运算数，将x直接压入栈s2；  
②若x是运算符，则分情况讨论：  
a)若x是'('，则直接压入栈s1；  
b)若x是')'，则将距离栈s1栈顶的最近的'('之间的运算符，逐个出栈，依次压入栈s2，此时抛弃'(‘；  
c)若x是除'('和')'外的运算符，则再分如下情况讨论：  
i)若当前栈s1的栈顶元素为'('，则将x直接压入栈s1；  
　　ii)若当前栈s1的栈顶元素不为'('，则将x与栈s1的栈顶元素比较，若x的优先级大于栈s1栈顶运算符优先级，则将x直接压入栈s1。否者，将栈s1的栈顶运算符弹出，压入栈s2中，直到栈s1的栈顶运算符优先级别低于（不包括等于）x的优先级，或栈s2的栈顶运算符为'('，此时再则将x压入栈s1;  
③在进行完②后，检查栈s1是否为空，若不为空，则将栈中元素依次弹出并压入栈s2中（不包括'#'）；  
1.1.3主要函数与数据结构定义   
①类定义  
   
convert方法对输入的正则表达式进行解析  
contrast存储代替字符与字符集合的映射  
  
②定义运算符的优先级  
 



③数据结构  
中缀表达式转换为后缀表达式的过程：
std::map<char, std::set<char>> RE::Parse(std::string regexp, std::string &reg_parsed)
涉及两个栈，执行上述1.1.2过程，返回映射表。
 

1.2解析后的正则表达式到NFAepsilon的转换
1.2.1 Thompson构造法:
Thompson构造法在计算机科学中是指一个能将正则表达式转化为一个与之等价的非确定有限状态自动机（NFA）的算法。算法得到的NFA可以在编程中用于匹配一个正则表达式，这也是正则表达式引擎实现的基本思路之一。

该构造法由一套构造规则组成：
递归终点
        对于正则表达式为ε或者只由一个符号构成的情况，则无需继续递归，对应的NFA可以直接由右侧规则给出：


子表达式运算的构造规则
设子表达式为s和t，则它们对应的NFA分别记作N(s)和N(t)。


（1）两个正则表达式的并s|t可以转化为：
 
（2）连接表达式s.t可以转化为：
 
（3）Kleene*闭包s*可以转化为：  
 
（4）Kleene+闭包s+可以转化为：
 
1.2.2 处理流程
 

1.2.3 主要函数与数据结构定义
①五元组定义
 
②图定义：
 
③定义的四种运算
 
④在处理流程中，使用栈来处理单元，对于处理过的后缀表达式，遇到操作数，构建单元，计算结果同样也是一个单元Unit，最后将整个Unit按照边依次存进五元组。
 


2 NFA-epsilon到DFA的转换
3.1 Subset construction算法介绍
Subset construction算法概念:
让构造得到的DFA的每个状态对应NFA的一个状态集合。DFA在读入a1a2...ana1a2...an之后到达的状态应该对应于相应的NFA从开始状态出发，沿着以a1a2...ana1a2...an为边的路径能达到的状态的集合。

3.2算法步骤
①根据NFA-ε 的txt文件中的起始状态q0，和状态转移函数，将q0和q0通过连续ε 所到达的所有节点构成一个新的状态A集合，将A加入NFA的状态集。
②将集合状态A中包含的所有节点，通过循环遍历符号集的各个符号生成相应的结果状态集合B',C',D'。
③将集合状态B',C',D'的各个状态进行连续的ε所到达的状态集合设置为B,C,D...，将B,C,D...状态 加入 NFA自动机的状态集。将A-->“符号”-->(B||C||D||...)加入状态转换函数。
④遍历A,B,C,D...状态集合，将包含q0的状态设置为起始状态，包含F的状态设置为F结束状态。


3.3结构流程图
 



3.4结构展示
（1）NFA-ε.txt截图
 
（2）存储NFA-ε的数据结构
 
（3）存储DFA的数据结构
 
（4）DFA.txt截图
 
（5）NFA-ε到DFA转换结构
 
存储NFA-ε的数据结构使用的是c++的stl中的set，multimap，pair等结构来应对NFA-ε的多对多关系。处理DFA的数据结构时采用的是多个set和自定义结构new_detal来存储。其中new_detal主要负责存储状态转移函数。状态的标识采用数字来区别方便进行转化。
3 DFA到极小化DFA的转换
3.1 极小化DFA与Hopcroft算法
A) 何谓极小化DFA？
1）没有多余状态（死状态）
      多余状态：
          ①从这个状态没有通路到达终态；
          ②从开始状态出发，任何输入串也不能到达的状态。
2）没有两个状态是互相等价（不可区别）
      两个状态s和t等价的条件：
          ①兼容性（一致性）条件——同是终态或同是非终态
          ②传播性（蔓延性）条件——对于所有输入符号，状     态s和状态t必须转换到等价的状态里。

B) Hopcroft算法伪代码：
 

C) Hopcroft 算法流程：
①设有非极小化的DFA，M，将M的状态划分为两个集合N（非终态）、A（终态）
②依次考察每个集合，如果该DFA的符号集中有符号能使得该集合中的状态经过该符号后到达不同的集合，则将该集合依据到达的集合进行划分，重新进行考察，否则继续考察下个集合
③如果集合仍在变化，则重复步骤2，否则划分结束
④划分结束后，在每个集合中指定一个代表状态来指定集合中的其他状态，更新DFA，即得到极小化的DFA
3.2 处理流程
 
3.3 主要函数与数据结构定义
①DFA的五元组和MINIDFA的五元组
 
②主要方法
 
ReadDFA：从文件中读取DFA五元组信息
Move：状态跳转
SetCount：获得经过跳转后能到达的集合的编号集合
Split：划分集合
GetMiniDFA：获得极小化的DFA
Show：打印函数
OutputMiniDFA2File：将极小化DFA的五元组信息输出到文件中

③数据结构
处理流程主要部分为Split函数：
 

indexedSet用来为集合指定一个编号，初始将集合划分为终止状态集合与非终止状态集合
 

存放当前已有集合
 

存放状态到转换后所达集合的序号的映射
 

存放划分后存在的集合的编号
 
4 实验结果展示
正则表达式："(([a~c].[A~D])*.([0~2]*.[A~B]|[a~e])*)+"
 
 
 
 
 



字符串测试：对于正则表达式： "([a~c]*.[1~3])"
 
 

5 总结与体会
付辰曦 实验心得
	本次实验我主要负责正则表达式的处理和正则表达式到NFA-epsilon的转换以及DFA到极小化DFA的转换过程。在本次实验中，分组实验的形式锻炼了我的团队合作能力与团队沟通能力。在实现中，用到了Thompson构造法、Hopcroft算法等算法，同时用到了很多基本结构例如栈、图等等，也用到了STL中实现好的结构，也用到了许多自定义的结构体，通过这些的使用，提高了我对STL的熟悉程度，使我对数据结构有了更深刻的认识，提高了我的编程能力。在对接过程中，我们通过指定五元组的输出文件格式，避免了许多不必要的麻烦，也让我体会到在这种团队合作的任务中，写代码不是首先要做的事，首先要做的事是对整个任务有一个整体上的认识和了解，划分好成员工作，选择好的对接方法，这样可以起到事半功倍的效果。另外在写代码的过程中要注意书写规范和命名规范，规范的命名能让人更好地理解代码，也便于自己理清思路。总体来说，本次实验让我的编程能力和组织能力都得到了锻炼，对以后的学习生活有很大的帮助。
刘煜 实验心得
实现NFA-ε到DFA是我本次实验的主要工作，其中难度最大的是理解Subset construction算法的基本思想和处理对应结构的存储。通过网络和课堂笔记等多方面渠道我解决了算法的部分。对于结构的存储我重新温习了stl 的用法和处理方式才有了相应的思路。在实现过程中，发现NFA到DFA中间可以直接进行相应的跳转，所以在本次实验中我对NFA的结构进行转型输出DFA.txt。
通过这次实验我学习到了很多东西，其中对我而言最重要的是对数据结构的重新认识和理解，合理使用正确的数据结构对程序本身而言是极为重要的。其次，对于面对对象编程有了一定的实践练习。编码过程中，组长付辰曦的代码风格也给了我许多的启发。最后，很高兴能参与这次实验，让我发现很多以前没有注意到的问题和瑕疵。

